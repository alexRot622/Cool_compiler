sequence(e) ::= "<e; separator=\"\n\">"
sequenceSpaced(e) ::= "<e; separator=\"\n\n\">"

heapStart() ::= <<
    .globl heap_start
heap_start:
    .word 0
>>

// DATA
dataSection(globals, tags, consts, nameTab, objTab, prots, dispTabs) ::=
<<
.align 2
<globals>
<tags>
<consts>
<nameTab>
<objTab>
<prots>
<dispTabs>
<heapStart()>
>>

tag(type, val) ::= <<
_<type>_tag:
    .word <val>

>>
program(data, textFuncs, textMain) ::= <<
.data
<data>

.text
<textFuncs>
>>

classProt(name, tag, size, attrs) ::= <<
<name>_protObj:
    .word <tag>
    .word <size>
    .word <name>_dispTab
    <sequence(attrs)>

>>

classDispTab(name, classes, methods) ::= <<
<name>_dispTab:
    <classes,methods:{class, method | .word <class>.<method><\n>}>
>>

classNameTab(names) ::= <<
class_nameTab:
    <names:{name | .word str_const<name><\n>}>
>>

objTab(classes) ::= <<
class_objTab:
    <classes:{class | .word <class>_protObj<\n>.word <class>_init<\n>}>
>>

intConst(tag, value) ::= <<
int_const<tag>:
    .word 2
    .word 4
    .word Int_dispTab
    .word <value>

>>

strConst(tag, size, lenTag, value) ::= <<
str_const<tag>:
    .word 3
    .word <size>
    .word String_dispTab
    .word int_const<lenTag>
    .asciiz "<value>"
    .align 2

>>

boolConst(tag, value) ::= <<
bool_const<tag>:
    .word 4
    .word 4
    .word Bool_dispTab
    .word <value>

>>

// TEXT
classInit(name, parentName, attrs) ::= <<
<name>_init:
    addiu $sp $sp -12
    sw $fp 12($sp)
    sw $s0 8($sp)
    sw $ra 4($sp)
    addiu $fp $sp 4
    move $s0 $a0
    <if(parentName)>jal <parentName>_init<endif>
<sequence(attrs)>
    move $a0 $s0
    lw $fp 12($sp)
    lw $s0 8($sp)
    lw $ra 4($sp)
    addiu $sp $sp 12
    jr $ra
>>

initAttr(offset) ::= <<
    sw $a0 <offset>($s0)
>>

mem(n) ::= <<
    addiu $sp $sp <n>
>>
// TODO: args
method(class, name, e, paramsSize) ::= <<
<class>.<name>:
    addiu $sp $sp -12
    sw $fp 12($sp)
    sw $s0 8($sp)
    sw $ra 4($sp)
    addiu $fp $sp 4
    move $s0 $a0
<e>
    lw $fp 12($sp)
    lw $s0 8($sp)
    lw $ra 4($sp)
    addiu $sp $sp 12
<if(paramsSize)><mem(paramsSize)><endif>
    jr $ra
>>

push(arg) ::= <<
<arg>
    sw $a0 0($sp)
    addiu $sp $sp -4
>>

call(offset, typename) ::= <<
<if(typename)>
    la $t1 <typename>_dispTab # dispatch table
<else>
    lw $t1 8($a0) # dispatch table
<endif>
    lw $t1 <offset>($t1) # method offset
    jalr $t1
>>

dispatch(caller, dispIdx, filenameTag, line, args, methodOffset, typename) ::= <<
<sequence(args)>
<caller>
    bnez $a0 dispatch<dispIdx>
    la $a0 str_const<filenameTag>
    li $t1 <line>
    jal _dispatch_abort
dispatch<dispIdx>:
<call(methodOffset, typename)>
>>

// EXPRESSIONS
literal(addr) ::= <<
    la $a0 <addr>
>>

// TODO (CRISTI): loads and assigns unified
loadVar(offset) ::= <<
    lw $a0 <offset>($s0)
>>

assignVar(offset) ::= <<
    sw $a0 <offset>($s0)
>>

loadParam(offset) ::= <<
    lw $a0 <offset>($fp)
>>

assignParam(offset) ::= <<
    sw $a0 <offset>($fp)
>>

newObj(class) ::= <<
    la $a0 <class>_protObj
    jal Object.copy
    jal <class>_init
>>

newSelfObj() ::= <<
    la $t1 class_objTab
    lw $t2 0($s0)
    sll $t2 $t2 3
    addu $t1 $t1 $t2
    sw $t1 0($sp)
    addiu $sp $sp -4
    lw $a0 0($t1)
    jal Object.copy
    lw $t1 4($sp)
    addiu $sp $sp 4
    lw $t1 4($t1)
    jalr $t1
>>

iff(cond, e1, e2, index) ::= <<
<cond>
    lw $t1 12($a0) # bool slot
    beqz $t1 else<index>
<e1>
    b endif<index>
else<index>:
<e2>
endif<index>:
>>